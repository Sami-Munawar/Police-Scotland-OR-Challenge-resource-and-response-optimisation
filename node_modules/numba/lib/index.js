"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.testNumba = exports.Numba = exports.PI = void 0;
exports.PI = Math.PI;
class NumbaFactory {
    get val() { return this; }
    pow(x) { return Math.pow(this.val, x); }
    powNorm(x, ceiling) {
        // power, but normalized to 0..1
        return (Math.pow((this.val / ceiling), x)) * ceiling;
    }
    powSign(x) { return this.sign * this.abs.pow(x); }
    get abs() { return Math.abs(this.val); }
    get sign() { return this.val < 0 ? -1 : this.val > 0 ? 1 : 0; }
    log(base = Math.E) { return Math.log(this.val) / Math.log(base); }
    get sin() { return Math.sin(this.val); }
    get cos() { return Math.cos(this.val); }
    get hyperSin() { return Math.sinh(this.val); }
    get aHyperSin() { return Math.asinh(this.val); }
    get floor() { return Math.floor(this.val); }
    get floorLeftover() { return this.val - this.floor; }
    get ceil() { return Math.ceil(this.val); }
    get round() { return Math.round(this.val); }
    rough(precision = 3) {
        const mul = Math.pow(10, precision);
        return (this.val * mul).round / mul;
    }
    // sometimes it`s handy to use basic operators in chains:
    // 1..add(2).mul(3).div(4).sub(5).pow(6).round
    add(x) { return this.val + x; }
    sub(x) { return this.val - x; }
    mul(x) { return this.val * x; }
    div(x) { return this.val / x; }
    get freq2bark() { return 6 * (this.val / 600).aHyperSin; }
    get bark2freq() { return 600 * (this.val / 6).hyperSin; }
    get note2freq() { return 440 * Math.pow(2, ((this.val - 69) / 12)); }
    get freq2note() { return 69 + 12 * (this.val / 440).log(2); }
    magnitudeSq(other) {
        return Math.pow(this.val, 2) + Math.pow(other, 2);
    }
    magnitude(other) {
        return Math.pow(this.magnitudeSq(other), .5);
    }
    get exp() { return Math.exp(this.val); }
    mix(a, b) { return a + (b - a) * this.val; }
    clamp(a, b) { const v = this.val; return v < a ? a : v > b ? b : v; }
    unMix(a, b) { return a == b ? a : (this.val - a) / (b - a); }
    remix(fromStart, fromEnd, toStart, toEnd) {
        return this.unMix(fromStart, fromEnd).mix(toStart, toEnd);
    }
    get isInteger() { return this.val % 1 == 0; }
    get isPowOf2() { return this.val > 0 && (this.val & (this.val - 1)) == 0; }
    get powOf2Above() { return Math.pow(2, (this.val.log(2).floor + 1)); }
    get powOf2Below() { return Math.pow(2, (this.val.log(2).ceil - 1)); }
    toFixedExp(digits = 2) {
        const n = this.val;
        if (digits <= 0) {
            return n.toFixed(digits + 3);
        }
        const s = n.toExponential(digits);
        const e = parseFloat(s.split('e').pop() || `0`).abs;
        if (e <= digits + 2)
            return n.isInteger ? n + `` : n.toFixed(digits + 3);
        return s;
    }
}
__decorate([
    N
], NumbaFactory.prototype, "val", null);
__decorate([
    N
], NumbaFactory.prototype, "pow", null);
__decorate([
    N
], NumbaFactory.prototype, "powNorm", null);
__decorate([
    N
], NumbaFactory.prototype, "powSign", null);
__decorate([
    N
], NumbaFactory.prototype, "abs", null);
__decorate([
    N
], NumbaFactory.prototype, "sign", null);
__decorate([
    N
], NumbaFactory.prototype, "log", null);
__decorate([
    N
], NumbaFactory.prototype, "sin", null);
__decorate([
    N
], NumbaFactory.prototype, "cos", null);
__decorate([
    N
], NumbaFactory.prototype, "hyperSin", null);
__decorate([
    N
], NumbaFactory.prototype, "aHyperSin", null);
__decorate([
    N
], NumbaFactory.prototype, "floor", null);
__decorate([
    N
], NumbaFactory.prototype, "floorLeftover", null);
__decorate([
    N
], NumbaFactory.prototype, "ceil", null);
__decorate([
    N
], NumbaFactory.prototype, "round", null);
__decorate([
    N
], NumbaFactory.prototype, "rough", null);
__decorate([
    N
], NumbaFactory.prototype, "add", null);
__decorate([
    N
], NumbaFactory.prototype, "sub", null);
__decorate([
    N
], NumbaFactory.prototype, "mul", null);
__decorate([
    N
], NumbaFactory.prototype, "div", null);
__decorate([
    N
], NumbaFactory.prototype, "freq2bark", null);
__decorate([
    N
], NumbaFactory.prototype, "bark2freq", null);
__decorate([
    N
], NumbaFactory.prototype, "note2freq", null);
__decorate([
    N
], NumbaFactory.prototype, "freq2note", null);
__decorate([
    N
], NumbaFactory.prototype, "magnitudeSq", null);
__decorate([
    N
], NumbaFactory.prototype, "magnitude", null);
__decorate([
    N
], NumbaFactory.prototype, "exp", null);
__decorate([
    N
], NumbaFactory.prototype, "mix", null);
__decorate([
    N
], NumbaFactory.prototype, "clamp", null);
__decorate([
    N
], NumbaFactory.prototype, "unMix", null);
__decorate([
    N
], NumbaFactory.prototype, "remix", null);
__decorate([
    N
], NumbaFactory.prototype, "isInteger", null);
__decorate([
    N
], NumbaFactory.prototype, "isPowOf2", null);
__decorate([
    N
], NumbaFactory.prototype, "powOf2Above", null);
__decorate([
    N
], NumbaFactory.prototype, "powOf2Below", null);
__decorate([
    N
], NumbaFactory.prototype, "toFixedExp", null);
/**
 * this function is a decorator factory that makes getter native to Array
 * @param target
 * @param propName
 */
function P(target, propName) {
    // console.log(`propertizing ${propName}!`, { target });
    const hiddenName = `¡ª${propName}`;
    Object.defineProperty(Number.prototype, propName, {
        set(v) { return this[hiddenName] = v; },
        get() { return this[hiddenName]; }
    });
}
///////////////////////////////////////////////
/**
 * this function is a decorator factory that makes the function or the property native to Array
 * @param target
 * @param fnName
 * @param fnCont
 */
function N(target, fnName, fnCont) {
    // console.log(`nativizing ${fnName}!`, { target, fnName, fnCont });
    if (fnCont.value) {
        Object.defineProperty(Number.prototype, fnName, {
            value(...args) {
                // console.log(`applying ${fnName} to ${this} with args ${args}`);
                return fnCont.value.apply(this, [...args]);
            }
        });
    }
    else if (fnCont.get) {
        Object.defineProperty(Number.prototype, fnName, {
            get() {
                // console.log(`applying getter ${fnName} to ${this}`);
                return fnCont.get.apply(this);
            }
        });
    }
}
class Numba {
    static includeMe() { return `thanks!`; }
}
exports.Numba = Numba;
function testNumba() {
    function showAct(act) {
        const res = act();
        console[res === false ? `error` : `log`](`${act.toString().split(`=>`)[0]}`, `=`, res);
    }
    const num1 = -2;
    console.info(`testing num1 =`, num1);
    showAct(() => num1.pow(2) == 4);
    showAct(() => num1.abs == 2);
    showAct(() => (.6).mix(100, 200) == 160);
    showAct(() => (55).unMix(100, 0) == .45);
    showAct(() => (150).remix(200, 100, -10, 0) == -5);
}
exports.testNumba = testNumba;
