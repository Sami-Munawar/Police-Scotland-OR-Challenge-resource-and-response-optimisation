export type num = number;// because I use it often
export type unit = number;// 0 to 1

export const PI = Math.PI;
class NumbaFactory {
    @N private get val(): number { return this as unknown as number; }
    @N pow(x: number) { return this.val ** x; }
    @N powNorm(x: num, ceiling: num) {
        // power, but normalized to 0..1
        return ((this.val / ceiling) ** x) * ceiling;
    }
    @N powSign(x: num) { return this.sign * this.abs.pow(x); }
    @N get abs() { return Math.abs(this.val); }
    @N get sign() { return this.val < 0 ? -1 : this.val > 0 ? 1 : 0; }
    @N log(base = Math.E) { return Math.log(this.val) / Math.log(base); }
    @N get sin() { return Math.sin(this.val); }
    @N get cos() { return Math.cos(this.val); }
    @N get hyperSin() { return Math.sinh(this.val); }
    @N get aHyperSin() { return Math.asinh(this.val); }
    @N get floor() { return Math.floor(this.val); }
    @N get floorLeftover() { return this.val - this.floor; }
    @N get ceil() { return Math.ceil(this.val); }
    @N get round() { return Math.round(this.val); }
    @N rough(precision = 3) {
        const mul = 10 ** precision;
        return (this.val * mul).round / mul;
    }
    // sometimes it`s handy to use basic operators in chains:
    // 1..add(2).mul(3).div(4).sub(5).pow(6).round
    @N add(x: num) { return this.val + x; }
    @N sub(x: num) { return this.val - x; }
    @N mul(x: num) { return this.val * x; }
    @N div(x: num) { return this.val / x; }

    @N get freq2bark() { return 6 * (this.val / 600).aHyperSin; }
    @N get bark2freq() { return 600 * (this.val / 6).hyperSin; }

    @N get note2freq() { return 440 * 2 ** ((this.val - 69) / 12); }
    @N get freq2note() { return 69 + 12 * (this.val / 440).log(2); }


    @N magnitudeSq(other: num) {
        return this.val ** 2 + other ** 2;
    }
    @N magnitude(other: num) {
        return this.magnitudeSq(other) ** .5;
    }

    @N get exp() { return Math.exp(this.val); }
    @N mix(a: num, b: num) { return a + (b - a) * this.val; }
    @N clamp(a: num, b: num) { const v = this.val; return v < a ? a : v > b ? b : v; }
    @N unMix(a: num, b: num) { return a == b ? a : (this.val - a) / (b - a); }
    @N remix(fromStart: num, fromEnd: num, toStart: num, toEnd: num) {
        return this.unMix(fromStart, fromEnd).mix(toStart, toEnd);
    }
    @N get isInteger() { return this.val % 1 == 0; }
    @N get isPowOf2() { return this.val > 0 && (this.val & (this.val - 1)) == 0; }
    @N get powOf2Above() { return 2 ** (this.val.log(2).floor + 1) }
    @N get powOf2Below() { return 2 ** (this.val.log(2).ceil - 1); }
    @N toFixedExp(digits = 2) {
        const n = this.val;
        if (digits <= 0) {
            return n.toFixed(digits + 3);
        }
        const s = n.toExponential(digits);
        const e = parseFloat(s.split('e').pop() || `0`).abs;
        if (e <= digits + 2) return n.isInteger ? n + `` : n.toFixed(digits + 3);
        return s;
    }

}

/**
 * this function is a decorator factory that makes getter native to Array
 * @param target 
 * @param propName 
 */
function P(target: Object, propName: string) {
    // console.log(`propertizing ${propName}!`, { target });
    const hiddenName = `¡ª${propName}`;
    Object.defineProperty(Number.prototype, propName, {
        set<T>(v: T) { return this[hiddenName] = v; },
        get() { return this[hiddenName]; }
    });

}
///////////////////////////////////////////////
/**
 * this function is a decorator factory that makes the function or the property native to Array
 * @param target 
 * @param fnName 
 * @param fnCont 
 */
function N(target: Object, fnName: string, fnCont: PropertyDescriptor) {
    // console.log(`nativizing ${fnName}!`, { target, fnName, fnCont });
    if (fnCont.value) {
        Object.defineProperty(Number.prototype, fnName, {
            value<T>(...args: T[]) {
                // console.log(`applying ${fnName} to ${this} with args ${args}`);
                return fnCont.value.apply(this, [...args]);
            }
        });
    } else if (fnCont.get) {
        Object.defineProperty(Number.prototype, fnName, {
            get<T>() {
                // console.log(`applying getter ${fnName} to ${this}`);
                return fnCont.get!.apply(this);
            }
        });
    }

}


export class Numba {
    static includeMe() { return `thanks!`; }
}
declare global {
    interface Number extends NumbaFactory {
    }
}


export function testNumba() {
    function showAct(act: () => any) {
        const res = act();
        console[res === false ? `error` : `log`](`${act.toString().split(`=>`)[0]}`, `=`, res);
    }
    const num1 = -2;
    console.info(`testing num1 =`, num1);
    showAct(() => num1.pow(2) == 4);
    showAct(() => num1.abs == 2);
    showAct(() => (.6).mix(100, 200) == 160);
    showAct(() => (55).unMix(100, 0) == .45);
    showAct(() => (150).remix(200, 100, -10, 0) == -5);
}